# Ray Tracer Challenge - Implementation

This repository contains a C++ implementation of the ray tracer spec outlined in _The Ray Tracer Challenge_ by Jamis Buck. Buck defines the specifications for the renderer using a test-driven approach, outlining program functionality as tests to make pass. I utilized Google Test for writing my test suites. 

The project is organized using a merged header and merged test philosophy, such that all related code files (headers, source, unit tests) are located in the same directory. src/ directory is organized related to program structure. The ray_tracer program itself is built from two statically linked libraries representing two layers of code. The first, the Graphics library (**gfx**), handles all lower level graphics computations and the associated code. **gfx** contains all data structures, geometry, and calculations related to shading and ray-object intersections. The second, higher layer, is the ray tracer program library (**rt**). **rt** handles functionality related to rendering images, and contains code for parsing scene data from JSON description (with help from nlohmann/json). **rt** interacts with **gfx** via the Camera which generates rays to be cast for processing by code in the **gfx** library.

Buck's architecture implicitly suggests an object-oriented approach, and--since I was coding in C++, I designed my implementation using classes. Generally, I tried to avoid mutable state in most of my objects--especially the core data structures. Some mutability did creep in in certain areas, but almost universally it was to facilitate testing the behavior of the object, and could easily be removed since no core functionality relied on it. I further strove to avoid deep inheritance hierarchies, though I utilized simple inheritence trees consisting of an abstract base class and concrete derived classes to define Surfaces and Patterns.
